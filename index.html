<h3>Part 1: What I did</h3>
<p>The two main objectives of this project were to allow to mutiple selection of nodes (to allow for modelling of a 'group' of edges at once) and the impplementation of the Catmull-Clark algorithm to better understand three dimensional meshes and how subdivision works to creat smoother images. </p>

<h3>Multiple/Loop selection of nodes</h3>

<p>To extend the base code to allow for multiple selection of edges, the starter code was modified in the following way:
<ol>
  <li>To begin multiple selection of nodes, users would select the 'y' key. To stop multiple selection, users would select the 'z' key. To allow for this, a few methods were added to meshEdit.cpp. The 2 methods that mark the beginning of common selection of nodes are setCommonCollectStatus() and removeCommonCollectStatus(). These methods set or unset a flag to show that common loop editing was being performed.</li>
<li>void MeshEdit::enactPotentialSelection() was modified to detect selected features and push them into a vector.
</li>
<li>void MeshEdit::drawEdges( HalfedgeMesh& mesh ) was modified to detect a change in the size of the vector storing selected mesh features and automatically adapt the element style

<code>
 // set the default style
            setElementStyle( elementAddress( e ) );

            // find if the current edge is contained as part of the selected edges
            if (selectedMeshFeatures.size() > 0)
            {
                for (std::vector<MeshFeature>::iterator iter = selectedMeshFeatures.begin();
                     iter != selectedMeshFeatures.end(); ++iter )
</code>
</li>
<li>The starter code was modified to create a new style that would represent the selected items that were being modified as a group of edges. This style was applied to edges using the method call setMultipleElementStyle(curr_e) and the new style was created in void MeshEdit::initializeStyle( void ) where it is referred to as combinedStyle with its halfedge, faceColor, edgeColor, vertexColor, strokeWidth and vertexRadius set.
</li>
<li>inline void MeshEdit::setElementStyle( HalfedgeElement* element ) was modified to detect for the edges(elements) that were being looped together for grouping. 
</li>
<li>inline void MeshEdit::setMultipleElementStyle(HalfedgeElement* element) was added to apply the combined style to the selected edges. 
</ol>

<h4>Results of multiple Loop selection</h4>
<ul>
<li>The modifications successfully allowed users to simultaneously select a number of edges and perform operations. 
</li>
<li>Since most operations as specified in assignment 2 included operations done to single edges e.g. edge flipping and collapse (which were thus unfeaseable as a operation that could be performed on multiple nodes), a method void performExtrusion(vector<HalfedgeElement*> edges) in main.cpp was created. However, there was no time to implement the code perform a simultaneous extrusion of the edges even though the code to do this was created.
</li>
</ul>

<h4>Image of loop selection in operation</h4>

<h3>Implementing Catmull Clark Subdivision algorithm</h3>

<p>The subdivision algorithm I created for the second part of the project subdivides a mesh using the Catmul Clark algorithm. To perform the subdivision, a user selects '9' to increased the subdivision rounds and thus make the image smoother and presses '0' to reduce the subdivision rounds and thus make the image less smoother i.e. reduce the number of triangles.
</p>

<p>To implement the Catmull-Clark algorithm, a number of changes to the starter code were made namely:
<ol>
<li>A global variable roundsCatmullClark was created and manipulated (i.e. increased or decreased) using the methods MeshEdit::addCatmullClarkSubdivisionLevels() and MeshEdit::removeCatmullClarkSubdivisionLevels(). These methods increased and reduced the number of Catmull-Clark subdivision levels.</li>

<li>These methods performed Catmull-Clark subdivision on all meshes in the scene. and finally by calling the method HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) in student_code.cpp to perform the actual Catmull-Clark subdivision steps
</li>
</ol>
</p>

<p>The actual steps taken to perform Catmull-Clark were based off Catmull &  Clarks' 1978 paper on the subdivision method and not on later modifications done to improve the algorithm.</p>

<p>The steps taken to implement the Catmull-Clark algorithm in the StarterCode in student_code.cpp in HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) were
<ol>
<li>Find the new face points: Here all edges were traversed and for each face, it's 3 Vector3D vertices were used to find the midpoint dubbed 'face points'.
</li>

<li>Finding new edge points: New edge points were determined by traversing each edge and finding the average of the 2 vertices of the edge and the newly created adjacent face points created on each side of the edge. 
</li>

<li>Moving vertices to create new control points: New control points or vertices were created by evaluating the formula:

<code> 
Q/n + 2R/n + S9n-3)/n 

where Q is the average of the sorrounding face points, R is the average of the sorrounding midpoints, S is the current control point/vertex and n is the valence (no of edges from the vertex)
</code>

<p>This formula then simplified out to:
<code>
Each new Vertex/Control point = Q/4+R/2+S/4 since n=4
</code>
</p>

<p>For each vertex, the function HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) in student_code.cpp calculated the average of neighboring face points, sorrounding mid points and summed the weighted values of these with the a weighted value of the current control point/vertex to determine the new vertex/control point of the current point</p>
</li>

<li>With an increased number of polygons (triangles in this case) representing the mesh generated, the new face points, edge points and control points/vertices were then joined together to created to form a new mesh that was passed back to the created function inline void MeshEdit::addCatmullClarkSubdivisionLevels() that called the method void MeshEdit::renderMesh( HalfedgeMesh& mesh ) in meshEdit.cpp to render the new mesh. </li>
</ol>
</p>
