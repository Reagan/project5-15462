<h3>Part 1: What I did</h3>
<p>The two main objectives of this project were to allow to mutiple selection of nodes (to allow for modelling of a 'group' of edges at once) and the implementation of the Catmull-Clark algorithm to better understand three dimensional meshes and how subdivision works to create smoother images. </p>

<p>The objectives of the project were to: 
<ol>
<li>Allow multiple selection of edges for 'loop' editing (i.e. edit a number of edges at the same time.</li>
<li>Implement the Catmull-Clark subdivision algorithm on rendered meshes. </li>
</ol>
</p>

<h3>Building the code</h3>

<p>All source files are in the /src folder and have been tested in the GHC clusters. Running the cmake.. and make commands from a created /build folder (similar to building previous projects) works just fine.
</p> 

<h3>Multiple/Loop selection of nodes</h3>

<p>In this first part of the project, the idea was to extend the base code to allow for multiple selection of edges. This would allow for functionality such as creating extrusions to create features such as fingers or hands as is available in common mesh editors such as modo and blender. The starter code was modified in the following way:
<ol>
  <li>To begin multiple selection of nodes, select the 'y' key. To stop multiple selection, select the 'z' key. To allow for this, a few methods were added to meshEdit.cpp. The 2 methods that mark the beginning of common selection of nodes are setCommonCollectStatus() and removeCommonCollectStatus(). These methods set or unset a flag to show that common loop editing was being performed.</li>
<li>void MeshEdit::enactPotentialSelection() was modified to detect selected features and push them into a vector.
</li>
<li>void MeshEdit::drawEdges( HalfedgeMesh& mesh ) was modified to detect a change in the size of the vector storing selected mesh features and automatically adapt the element style

```c
 // set the default style
            setElementStyle( elementAddress( e ) );

            // find if the current edge is contained as part of the selected edges
            if (selectedMeshFeatures.size() > 0)
            {
                for (std::vector<MeshFeature>::iterator iter = selectedMeshFeatures.begin();
                     iter != selectedMeshFeatures.end(); ++iter )
```
</li>
<li>The starter code was modified to create a new style that would represent the selected items that were being modified as a group of edges. This style was applied to edges using the method call setMultipleElementStyle(curr_e) and the new style was created in void MeshEdit::initializeStyle( void ) where it is referred to as combinedStyle with its halfedge, faceColor, edgeColor, vertexColor, strokeWidth and vertexRadius set.
</li>
<li>inline void MeshEdit::setElementStyle( HalfedgeElement* element ) was modified to detect for the edges(elements) that were being looped together for grouping. 
</li>
<li>inline void MeshEdit::setMultipleElementStyle(HalfedgeElement* element) was added to apply the combined style to the selected edges. 
</ol>

<h4>Results of multiple Loop selection</h4>
<ul>
<li>The modifications successfully allowed users to simultaneously select a number of edges and perform operations. 
</li>
<li>Since most operations as specified in assignment 2 included operations done to single edges e.g. edge flipping and collapse (which were thus unfeaseable as a operation that could be performed on multiple nodes), a method void performExtrusion(vector<HalfedgeElement*> edges) in main.cpp was created. However, there was no time to implement the code perform a simultaneous extrusion of the edges even though the code to do this was created.
</li>
</ul>

<h4>Image of loop selection in operation</h4>

<h3>Implementing Catmull Clark Subdivision algorithm</h3>

<p>The subdivision algorithm I created for the second part of the project subdivides a mesh using the Catmul Clark algorithm. To perform the subdivision, a user selects '9' to increased the subdivision rounds and thus make the image smoother and presses '0' to reduce the subdivision rounds and thus make the image less smoother i.e. reduce the number of triangles.
</p>

<p>To implement the Catmull-Clark algorithm, a number of changes to the starter code were made namely:
<ol>
<li>A global variable roundsCatmullClark was created and manipulated (i.e. increased or decreased) using the methods MeshEdit::addCatmullClarkSubdivisionLevels() and MeshEdit::removeCatmullClarkSubdivisionLevels(). These methods increased and reduced the number of Catmull-Clark subdivision levels.</li>

<li>These methods performed Catmull-Clark subdivision on all meshes in the scene. and finally by calling the method HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) in student_code.cpp to perform the actual Catmull-Clark subdivision steps
</li>
</ol>
</p>

<p>The actual steps taken to perform Catmull-Clark were based off Catmull &  Clarks' 1978 paper on the subdivision method and not on later modifications done to improve the algorithm.</p>

<p>The steps taken to implement the Catmull-Clark algorithm in the StarterCode in student_code.cpp in HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) were
<ol>
<li>Find the new face points: Here all edges were traversed and for each face, it's 3 Vector3D vertices were used to find the midpoint dubbed 'face points'.
</li>

<li>Finding new edge points: New edge points were determined by traversing each edge and finding the average of the 2 vertices of the edge and the newly created adjacent face points created on each side of the edge. 
</li>

<li>Moving vertices to create new control points: New control points or vertices were created by evaluating the formula:

<code> 
Q/n + 2R/n + S9n-3)/n 

where Q is the average of the sorrounding face points, R is the average of the sorrounding midpoints, S is the current control point/vertex and n is the valence (no of edges from the vertex)
</code>

<p>This formula then simplified out to:
<code>
Each new Vertex/Control point = Q/4+R/2+S/4 since n=4
</code>
</p>

<p>For each vertex, the function HalfedgeMesh* MeshResampler::catmullClarkSubdivide( HalfedgeMesh& mesh, int rounds ) in student_code.cpp calculated the average of neighboring face points, sorrounding mid points and summed the weighted values of these with the a weighted value of the current control point/vertex to determine the new vertex/control point of the current point</p>
</li>

<li>With an increased number of polygons (triangles in this case) representing the mesh generated, the new face points, edge points and control points/vertices were then joined together to created to form a new mesh that was passed back to the created function inline void MeshEdit::addCatmullClarkSubdivisionLevels() that called the method void MeshEdit::renderMesh( HalfedgeMesh& mesh ) in meshEdit.cpp to render the new mesh. </li>
</ol>

<h4>Results of the Catmull Clark Subdivision</h4>

<p>Considerable modification was required to modify the starter code since the code was written to load a Scene from a collada file and render a mesh once allowing for localized modifications  such as edge flips and collapsing. However for the Catmull-Clark algorithm, an entirely new mesh was created to replace an old one and rendered. The main challenge in creating and rendering a new mesh as required by Catmull clark was that there only existed one method to create new meshes namely <code>void HalfedgeMesh :: build( const vector< vector<Index> >& polygons,const vector<Vector3D>& vertexPositions ) </code>. More discrete methods such as Edge MeshEdit::createEdge(Vector3D start, Vector3D end), Face MeshEdit::createFace(Vector3D v1, Vector3D v2, Vector3D v3), Vertex MeshEdit::createVertex(Vector3D v) were created to allow for the creation of Edges, Vertices and Faces. However, meshes rendered  using the created routines had holes (not manifold), in some cases caused the viewer to crash or render the mesh incorrectly. With more time, more work could have been covered here.
</p>
